name: Dev - Deploy to AKS (after CI)

on:
  # Auto-run after CI on testing finishes
  workflow_run:
    workflows: ["CI - Test, Build & Push (testing)"]
    types: [completed]
  # Manual Run button
  workflow_dispatch: {}

env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  ACR_NAME: ${{ secrets.ACR_NAME }}
  AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
  DEV_NAMESPACE: dev

jobs:
  deploy_dev:
    # only when CI succeeded on the 'testing' branch, or manual run
    if: ${{ github.event_name == 'workflow_dispatch' ||
            (github.event_name == 'workflow_run' &&
             github.event.workflow_run.conclusion == 'success' &&
             github.event.workflow_run.head_branch == 'testing') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (same commit as CI run)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ secrets.AKS_RG }}
          cluster-name:   ${{ secrets.AKS_CLUSTER_NAME }}
          subscription:   ${{ secrets.AZ_SUBSCRIPTION_ID }}

      - name: Ensure dev namespace
        run: kubectl create namespace "${{ env.DEV_NAMESPACE }}" --dry-run=client -o yaml | kubectl apply -f -

      # Use the Service Principal (AcrPull on ACR) to create pull secret
      - name: Create/Update ACR pull secret (dev via SP)
        env:
          SP_CLIENT_ID:     ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientId }}
          SP_CLIENT_SECRET: ${{ fromJSON(secrets.AZURE_CREDENTIALS).clientSecret }}
        run: |
          kubectl create secret docker-registry acr-pull \
            --namespace "${{ env.DEV_NAMESPACE }}" \
            --docker-server="${{ env.ACR_LOGIN_SERVER }}" \
            --docker-username="${SP_CLIENT_ID}" \
            --docker-password="${SP_CLIENT_SECRET}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Link imagePullSecret to default SA (dev)
        run: |
          kubectl patch serviceaccount default -n "${{ env.DEV_NAMESPACE }}" \
            -p '{"imagePullSecrets":[{"name":"acr-pull"}]}'

      - name: Determine image tag (from CI commit)
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "IMAGE_TAG=${GITHUB_SHA}" >> $GITHUB_ENV
          else
            echo "IMAGE_TAG=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_ENV
          fi

      - name: Verify manifests present
        run: |
          test -d k8s/prod || { echo "k8s/prod not found in this ref."; exit 1; }
          ls -la k8s/prod

      - name: Apply manifests to dev (with image vars)
        run: |
          set -euo pipefail
          sudo apt-get update && sudo apt-get install -y gettext-base
          for f in k8s/prod/*.yaml; do
            echo "Applying $f ..."
            ACR_LOGIN_SERVER="${{ env.ACR_LOGIN_SERVER }}" GITHUB_SHA="${IMAGE_TAG}" \
            envsubst < "$f" | kubectl apply -n "${{ env.DEV_NAMESPACE }}" -f -
          done

      - name: Debug - show what got deployed
        run: kubectl get deploy,po,svc -n "${{ env.DEV_NAMESPACE }}" -o wide

      - name: Wait for rollouts (dev)
        run: |
          set -e
          for d in product-service order-service customer-service frontend; do
            kubectl rollout status -n "${{ env.DEV_NAMESPACE }}" deployment/$d --timeout=240s
          done

      - name: Show services (dev)
        run: kubectl get svc -n "${{ env.DEV_NAMESPACE }}"
